// Generated by TaroBase SDK Generator: 2025-08-30T03:46:22.951Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@tarobase/js-sdk';
import { getFiles, setFile } from '@tarobase/js-sdk';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@tarobase/js-sdk'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

export type TokenName = 'USDC' | 'SOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * @param key A PublicKey instance or a base58 encoded public key string.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    let pkInstance: PublicKey;
    if (typeof key === 'string') {
      try {
        // Validate and create PublicKey from string
        pkInstance = new PublicKey(key);
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}`);
      }
    } else if (key instanceof PublicKey) {
       // Use the provided PublicKey instance directly
      pkInstance = key;
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
    // Return the structured AddressType object
    return {
      type: 'address',
      publicKey: pkInstance,
    };
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Generated Functions by Policy Path ---

// --- Path: uniblock/$requestId ---

// --- Path: uniblock/$requestId --- (Uniblock – typed wrappers, hard‑coded requestId=1)

export type UniblockChainId =
  | 'solana'
  | 'solana-devnet'
  | 1 | 8453 | 42161 | number;

export interface WalletTokenBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletTokenBalanceResponseItem { contractAddress: string; balance: string; name: string; symbol: string; logo: string; decimals: string; }
export interface WalletTokenBalanceResponse { balances: WalletTokenBalanceResponseItem[]; }
export async function getWalletTokenBalance({ walletAddress, chainId = 'solana' }: WalletTokenBalanceParams): Promise<WalletTokenBalanceResponse> {
  const body = { operationId: 'WalletTokenBalance', operationInputData: { walletAddress, chainId, includePrice: true } };
  return (await set("uniblock/1", body)) as WalletTokenBalanceResponse;
}

export interface TokenPriceParams { contractAddress: string; chainId?: UniblockChainId; }
export interface TokenPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; }
export async function getTokenPrice({ contractAddress, chainId = 'solana' }: TokenPriceParams): Promise<TokenPriceResponse> {
  const body = { operationId: 'TokenPrice', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenPriceResponse;
}

export interface TokenHistoricalPriceParams { contractAddress: string; chainId?: UniblockChainId; timestamp?: number; blockNumber?: number; }
export interface TokenHistoricalPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; blockNumber: string; timestamp: string; }
export async function getTokenHistoricalPrice({ contractAddress, chainId = 'solana', timestamp, blockNumber }: TokenHistoricalPriceParams): Promise<TokenHistoricalPriceResponse> {
  const body = { operationId: 'TokenHistoricalPrice', operationInputData: { contractAddress, chainId, timestamp, blockNumber } };
  return (await set("uniblock/1", body)) as TokenHistoricalPriceResponse;
}

export interface WalletNFTBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletNFTBalanceResponseItem { contractAddress: string; tokenId: string; name: string; symbol: string; image: string; }
export interface WalletNFTBalanceResponse { balances: WalletNFTBalanceResponseItem[]; }
export async function getWalletNFTBalance({ walletAddress, chainId = 'solana' }: WalletNFTBalanceParams): Promise<WalletNFTBalanceResponse> {
  const body = { operationId: 'WalletNFTBalance', operationInputData: { walletAddress, chainId } };
  return (await set("uniblock/1", body)) as WalletNFTBalanceResponse;
}

export interface NFTCollectionMetadataParams { contractAddress: string; chainId?: UniblockChainId; }
export interface NFTCollectionMetadataResponse { address: string; name: string; symbol: string; type: string; }
export async function getNFTCollectionMetadata({ contractAddress, chainId = 'solana' }: NFTCollectionMetadataParams): Promise<NFTCollectionMetadataResponse> {
  const body = { operationId: 'NFTCollectionMetadata', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as NFTCollectionMetadataResponse;
}

export interface NFTMetadataParams { contractAddress: string; tokenId: string; chainId?: UniblockChainId; }
export interface NFTMetadataResponse { contractAddress: string; contractType: string; metadata: any; rawMetadata: string; lastUpdated: string; contractMetadata: any; }
export async function getNFTMetadata({ contractAddress, tokenId, chainId = 'solana' }: NFTMetadataParams): Promise<NFTMetadataResponse> {
  const body = { operationId: 'NFTMetadata', operationInputData: { contractAddress, tokenId, chainId } };
  return (await set("uniblock/1", body)) as NFTMetadataResponse;
}

export interface TokenMetadataParams { tokenAddress: string; chainId?: UniblockChainId; }
export interface TokenMetadataResponse { name: string; symbol: string; logo: string; decimals: string; }
export async function getTokenMetadata({ tokenAddress, chainId = 'solana' }: TokenMetadataParams): Promise<TokenMetadataResponse> {
  const body = { operationId: 'TokenMetadata', operationInputData: { tokenAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenMetadataResponse;
}
// --- Path: appFiles/$fileId ---

/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`appFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 */
export async function uploadAppFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `appFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: uploadedImages/$imageId ---

/**
 * Handles UploadedImages files (Get Single File based on its ID, null if not found)
 */
export async function getUploadedImages(imageId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`uploadedImages/${imageId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles UploadedImages files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getUploadedImages function right after this one.
 */
export async function uploadUploadedImages(imageId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `uploadedImages/${imageId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Handles UploadedImages files (Delete File based on its ID, returns true if successful)
 */
export async function deleteUploadedImages(imageId: string): Promise<boolean> {
  try {
    await setFile(`uploadedImages/${imageId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: tokens/$tokenId ---

export interface TokensRequest {
  tokenName: string;
  tokenSymbol: string;
  tokenImageUri: string;
  virtualSolReserves?: number | TimeOperation | TokenAmount;
  virtualTokenReserves?: number | TimeOperation | TokenAmount;
  actualSolReserves?: number | TimeOperation | TokenAmount;
  actualTokenReserves?: number | TimeOperation | TokenAmount;
}

export interface TokensResponse {
  tokenName: string;
  tokenSymbol: string;
  tokenImageUri: string;
  virtualSolReserves?: number;
  virtualTokenReserves?: number;
  actualSolReserves?: number;
  actualTokenReserves?: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a Tokens operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildTokens(tokenId: string, data: TokensRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `tokens/${tokenId}`, document: doc };
}

/**
 * Authentication required. Admin-only (address must equal '6V9ng1g3UgafjCrCgXNBF4SwXbARB89YP9i8rAhY7Xem'). Creating this document WILL EXECUTE hooks that mint 1000000000000000 smallest-unit tokens to the contract address and set up the escrow PDA used later for the LP mechanics. (Create/Update Single Item)
 */
export async function setTokens(tokenId: string, data: TokensRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`tokens/${tokenId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Tokens: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view SOF token metadata, total supply, reserves, and related statistics.
   (Get Single Item)
 */
export async function getTokens(tokenId: string): Promise<TokensResponse | null> {
  try {
    const result = await get(`tokens/${tokenId}`);
    return result as TokensResponse | null;
  } catch (error) {
    console.error(`Error getting Tokens: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Tokens document. (
  Read Operation Details: Public access. Anyone can view SOF token metadata, total supply, reserves, and related statistics.
  )
 */
export function subscribeTokens(callback: (data: TokensResponse | null) => void, tokenId: string): Promise<() => Promise<void>> {
  return subscribe(`tokens/${tokenId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as TokensResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Tokens at path '${`tokens/${tokenId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Tokens items from collection tokens
 
  Read Operation Details: Public access. Anyone can view SOF token metadata, total supply, reserves, and related statistics.
  
 */
export async function getManyTokens(filter: string = ""): Promise<TokensResponse[]> {
  try {
    const results = await get("tokens", { prompt: filter });
    return Array.isArray(results) ? results as TokensResponse[] : [];
  } catch (error) {
    console.error(`Error getting Tokens collection at path 'tokens': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Tokens collection at tokens
 
  Read Operation Details: Public access. Anyone can view SOF token metadata, total supply, reserves, and related statistics.
  
 */
export function subscribeManyTokens(callback: (data: TokensResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("tokens", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as TokensResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Tokens collection at path '${"tokens"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getTokenMintAddress" query on Tokens.
 * Query Logic: @TokenPlugin.getTokenMintAddress($tokenId, @data.tokenName, @data.tokenSymbol)
 */
export async function runGetTokenMintAddressQueryForTokens(tokenId: string, ): Promise<string> {
  try {
    const result = await runQuery(`tokens/${tokenId}`, "getTokenMintAddress", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getTokenMintAddress" on Tokens: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Runs the "getUserTokenBalance" query on Tokens.
 * Query Logic: @TokenPlugin.getBalance(@user.address, @TokenPlugin.getTokenMintAddress($tokenId, @data.tokenName, @data.tokenSymbol))
 */
export async function runGetUserTokenBalanceQueryForTokens(tokenId: string, ): Promise<number> {
  try {
    const result = await runQuery(`tokens/${tokenId}`, "getUserTokenBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getUserTokenBalance" on Tokens: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Runs the "getTotalSupply" query on Tokens.
 * Query Logic: @TokenPlugin.getSupply(@TokenPlugin.getTokenMintAddress($tokenId, @data.tokenName, @data.tokenSymbol))
 */
export async function runGetTotalSupplyQueryForTokens(tokenId: string, ): Promise<number> {
  try {
    const result = await runQuery(`tokens/${tokenId}`, "getTotalSupply", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getTotalSupply" on Tokens: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Runs the "getBurnedTokens" query on Tokens.
 * Query Logic: 1000000000000000 - @TokenPlugin.getSupply(@TokenPlugin.getTokenMintAddress($tokenId, @data.tokenName, @data.tokenSymbol))
 */
export async function runGetBurnedTokensQueryForTokens(tokenId: string, ): Promise<number> {
  try {
    const result = await runQuery(`tokens/${tokenId}`, "getBurnedTokens", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getBurnedTokens" on Tokens: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: tokens/$tokenId/transfers/$transferId ---

export interface TokensTransfersRequest {
  from: AddressType;
  to: AddressType;
  tokenAmount: number | TimeOperation | TokenAmount;
}

export interface TokensTransfersResponse {
  from: string;
  to: string;
  tokenAmount: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a TokensTransfers operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildTokensTransfers(tokenId: string, transferId: string, data: TokensTransfersRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `tokens/${tokenId}/transfers/${transferId}`, document: doc };
}

/**
 * Authentication required. Implements token transfer plus a burn equal to (5 / 10000) of the amount. The from field must match the caller. Creating this document WILL EXECUTE a hook that transfers (10000 - 5) / 10000 of the tokens to the recipient and burns the remainder. (Create/Update Single Item)
 */
export async function setTokensTransfers(tokenId: string, transferId: string, data: TokensTransfersRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`tokens/${tokenId}/transfers/${transferId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting TokensTransfers: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view token transfer analytics.
   (Get Single Item)
 */
export async function getTokensTransfers(tokenId: string, transferId: string): Promise<TokensTransfersResponse | null> {
  try {
    const result = await get(`tokens/${tokenId}/transfers/${transferId}`);
    return result as TokensTransfersResponse | null;
  } catch (error) {
    console.error(`Error getting TokensTransfers: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single TokensTransfers document. (
  Read Operation Details: Public access. Anyone can view token transfer analytics.
  )
 */
export function subscribeTokensTransfers(callback: (data: TokensTransfersResponse | null) => void, tokenId: string, transferId: string): Promise<() => Promise<void>> {
  return subscribe(`tokens/${tokenId}/transfers/${transferId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as TokensTransfersResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to TokensTransfers at path '${`tokens/${tokenId}/transfers/${transferId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many TokensTransfers items from collection tokens/${tokenId}/transfers
 
  Read Operation Details: Public access. Anyone can view token transfer analytics.
  
 */
export async function getManyTokensTransfers(tokenId: string, filter: string = ""): Promise<TokensTransfersResponse[]> {
  try {
    const results = await get(`tokens/${tokenId}/transfers`, { prompt: filter });
    return Array.isArray(results) ? results as TokensTransfersResponse[] : [];
  } catch (error) {
    console.error(`Error getting TokensTransfers collection at path 'tokens/${tokenId}/transfers': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in TokensTransfers collection at tokens/${tokenId}/transfers
 
  Read Operation Details: Public access. Anyone can view token transfer analytics.
  
 */
export function subscribeManyTokensTransfers(callback: (data: TokensTransfersResponse[]) => void, tokenId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`tokens/${tokenId}/transfers`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as TokensTransfersResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to TokensTransfers collection at path '${`tokens/${tokenId}/transfers`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: liquidityPools/$poolId ---

export interface LiquidityPoolsRequest {
  owner: AddressType;
  tokenMintAddress: AddressType;
  tokenStaked: number | TimeOperation | TokenAmount;
  solStaked: number | TimeOperation | TokenAmount;
  isDonated: boolean;
}

export interface LiquidityPoolsResponse {
  owner: string;
  tokenMintAddress: string;
  tokenStaked: number;
  solStaked: number;
  isDonated: boolean;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a LiquidityPools operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLiquidityPools(poolId: string, data: LiquidityPoolsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `liquidityPools/${poolId}`, document: doc };
}

/**
 * Admin-only ('6V9ng1g3UgafjCrCgXNBF4SwXbARB89YP9i8rAhY7Xem'). Two scenarios: (a) Game-owned LP (isDonated = false) which the admin manages and collects fees from; (b) Donated LP (isDonated = true) whose LP tokens are effectively renounced. The creator must supply both solStaked and tokenStaked > 0. Creating this document WILL EXECUTE a hook that creates a DeFi pool and moves both SOL and token to the escrow PDA. (Create/Update Single Item)
 */
export async function setLiquidityPools(poolId: string, data: LiquidityPoolsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`liquidityPools/${poolId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LiquidityPools: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type LiquidityPoolsRequestUpdate = Partial<LiquidityPoolsRequest>;

/**
 * Build a LiquidityPools update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateLiquidityPools(poolId: string, data: LiquidityPoolsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `liquidityPools/${poolId}`, document: doc };
}

/**
 * Authentication required. Only the admin can update pool metadata. Donated pools (isDonated = true) should never be modified after creation. (Update Single Item)
 */
export async function updateLiquidityPools(poolId: string, data: LiquidityPoolsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`liquidityPools/${poolId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating LiquidityPools: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can inspect LP pools, including whether they are game-owned (fee generating) or donated (permanent liquidity).
   (Get Single Item)
 */
export async function getLiquidityPools(poolId: string): Promise<LiquidityPoolsResponse | null> {
  try {
    const result = await get(`liquidityPools/${poolId}`);
    return result as LiquidityPoolsResponse | null;
  } catch (error) {
    console.error(`Error getting LiquidityPools: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LiquidityPools document. (
  Read Operation Details: Public access. Anyone can inspect LP pools, including whether they are game-owned (fee generating) or donated (permanent liquidity).
  )
 */
export function subscribeLiquidityPools(callback: (data: LiquidityPoolsResponse | null) => void, poolId: string): Promise<() => Promise<void>> {
  return subscribe(`liquidityPools/${poolId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LiquidityPoolsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LiquidityPools at path '${`liquidityPools/${poolId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many LiquidityPools items from collection liquidityPools
 
  Read Operation Details: Public access. Anyone can inspect LP pools, including whether they are game-owned (fee generating) or donated (permanent liquidity).
  
 */
export async function getManyLiquidityPools(filter: string = ""): Promise<LiquidityPoolsResponse[]> {
  try {
    const results = await get("liquidityPools", { prompt: filter });
    return Array.isArray(results) ? results as LiquidityPoolsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LiquidityPools collection at path 'liquidityPools': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LiquidityPools collection at liquidityPools
 
  Read Operation Details: Public access. Anyone can inspect LP pools, including whether they are game-owned (fee generating) or donated (permanent liquidity).
  
 */
export function subscribeManyLiquidityPools(callback: (data: LiquidityPoolsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("liquidityPools", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LiquidityPoolsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LiquidityPools collection at path '${"liquidityPools"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getPoolSolBalance" query on LiquidityPools.
 * Query Logic: @TokenPlugin.getBalance($poolId, @TokenPlugin.SOL)
 */
export async function runGetPoolSolBalanceQueryForLiquidityPools(poolId: string, ): Promise<number> {
  try {
    const result = await runQuery(`liquidityPools/${poolId}`, "getPoolSolBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPoolSolBalance" on LiquidityPools: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Runs the "getPoolTokenBalance" query on LiquidityPools.
 * Query Logic: @TokenPlugin.getBalance($poolId, @data.tokenMintAddress)
 */
export async function runGetPoolTokenBalanceQueryForLiquidityPools(poolId: string, ): Promise<number> {
  try {
    const result = await runQuery(`liquidityPools/${poolId}`, "getPoolTokenBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPoolTokenBalance" on LiquidityPools: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: jackpots/$jackpotId ---

export interface JackpotsRequest {
  isOpen: boolean;
  potLamports: number | TimeOperation | TokenAmount;
  grandWinner?: AddressType;
  secondWinner?: AddressType;
  thirdWinner?: AddressType;
}

export interface JackpotsResponse {
  isOpen: boolean;
  potLamports: number;
  grandWinner?: string;
  secondWinner?: string;
  thirdWinner?: string;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a Jackpots operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildJackpots(jackpotId: string, data: JackpotsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `jackpots/${jackpotId}`, document: doc };
}

/**
 * Admin-only ('6V9ng1g3UgafjCrCgXNBF4SwXbARB89YP9i8rAhY7Xem'). Opens a new SOL jackpot pot (isOpen = true, potLamports = 0). Creating this document WILL EXECUTE a hook that creates the escrow PDA. (Create/Update Single Item)
 */
export async function setJackpots(jackpotId: string, data: JackpotsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`jackpots/${jackpotId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Jackpots: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type JackpotsRequestUpdate = Partial<JackpotsRequest>;

/**
 * Build a Jackpots update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateJackpots(jackpotId: string, data: JackpotsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `jackpots/${jackpotId}`, document: doc };
}

/**
 * Admin-only ('6V9ng1g3UgafjCrCgXNBF4SwXbARB89YP9i8rAhY7Xem'). Used to close a jackpot (isOpen → false). Updating this WILL EXECUTE hooks distributing SOL to winners, the DCA wallet, and resetting potLamports. (Update Single Item)
 */
export async function updateJackpots(jackpotId: string, data: JackpotsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`jackpots/${jackpotId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating Jackpots: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view jackpot pot size and winners.
   (Get Single Item)
 */
export async function getJackpots(jackpotId: string): Promise<JackpotsResponse | null> {
  try {
    const result = await get(`jackpots/${jackpotId}`);
    return result as JackpotsResponse | null;
  } catch (error) {
    console.error(`Error getting Jackpots: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Jackpots document. (
  Read Operation Details: Public access. Anyone can view jackpot pot size and winners.
  )
 */
export function subscribeJackpots(callback: (data: JackpotsResponse | null) => void, jackpotId: string): Promise<() => Promise<void>> {
  return subscribe(`jackpots/${jackpotId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as JackpotsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Jackpots at path '${`jackpots/${jackpotId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Jackpots items from collection jackpots
 
  Read Operation Details: Public access. Anyone can view jackpot pot size and winners.
  
 */
export async function getManyJackpots(filter: string = ""): Promise<JackpotsResponse[]> {
  try {
    const results = await get("jackpots", { prompt: filter });
    return Array.isArray(results) ? results as JackpotsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Jackpots collection at path 'jackpots': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Jackpots collection at jackpots
 
  Read Operation Details: Public access. Anyone can view jackpot pot size and winners.
  
 */
export function subscribeManyJackpots(callback: (data: JackpotsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("jackpots", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as JackpotsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Jackpots collection at path '${"jackpots"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getPotSolBalance" query on Jackpots.
 * Query Logic: @TokenPlugin.getBalance($jackpotId, @TokenPlugin.SOL)
 */
export async function runGetPotSolBalanceQueryForJackpots(jackpotId: string, ): Promise<number> {
  try {
    const result = await runQuery(`jackpots/${jackpotId}`, "getPotSolBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPotSolBalance" on Jackpots: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: jackpots/$jackpotId/deposits/$depositId ---

export interface JackpotsDepositsRequest {
  from: AddressType;
  amount: number | TimeOperation | TokenAmount;
}

export interface JackpotsDepositsResponse {
  from: string;
  amount: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a JackpotsDeposits operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildJackpotsDeposits(jackpotId: string, depositId: string, data: JackpotsDepositsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `jackpots/${jackpotId}/deposits/${depositId}`, document: doc };
}

/**
 * Authentication required. Deposits SOL directly into the jackpot escrow. The from field must match the caller. amount > 0 and jackpot must be open. Creating this document WILL EXECUTE a hook that transfers SOL and increments potLamports. (Create/Update Single Item)
 */
export async function setJackpotsDeposits(jackpotId: string, depositId: string, data: JackpotsDepositsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`jackpots/${jackpotId}/deposits/${depositId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting JackpotsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view SOL deposits into an open jackpot pot.
   (Get Single Item)
 */
export async function getJackpotsDeposits(jackpotId: string, depositId: string): Promise<JackpotsDepositsResponse | null> {
  try {
    const result = await get(`jackpots/${jackpotId}/deposits/${depositId}`);
    return result as JackpotsDepositsResponse | null;
  } catch (error) {
    console.error(`Error getting JackpotsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single JackpotsDeposits document. (
  Read Operation Details: Public access. Anyone can view SOL deposits into an open jackpot pot.
  )
 */
export function subscribeJackpotsDeposits(callback: (data: JackpotsDepositsResponse | null) => void, jackpotId: string, depositId: string): Promise<() => Promise<void>> {
  return subscribe(`jackpots/${jackpotId}/deposits/${depositId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as JackpotsDepositsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to JackpotsDeposits at path '${`jackpots/${jackpotId}/deposits/${depositId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many JackpotsDeposits items from collection jackpots/${jackpotId}/deposits
 
  Read Operation Details: Public access. Anyone can view SOL deposits into an open jackpot pot.
  
 */
export async function getManyJackpotsDeposits(jackpotId: string, filter: string = ""): Promise<JackpotsDepositsResponse[]> {
  try {
    const results = await get(`jackpots/${jackpotId}/deposits`, { prompt: filter });
    return Array.isArray(results) ? results as JackpotsDepositsResponse[] : [];
  } catch (error) {
    console.error(`Error getting JackpotsDeposits collection at path 'jackpots/${jackpotId}/deposits': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in JackpotsDeposits collection at jackpots/${jackpotId}/deposits
 
  Read Operation Details: Public access. Anyone can view SOL deposits into an open jackpot pot.
  
 */
export function subscribeManyJackpotsDeposits(callback: (data: JackpotsDepositsResponse[]) => void, jackpotId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`jackpots/${jackpotId}/deposits`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as JackpotsDepositsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to JackpotsDeposits collection at path '${`jackpots/${jackpotId}/deposits`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: operations/$tokenId/buyToken/$buyTokenId ---

export interface OperationsBuyTokenRequest {
  solAmount: number | TimeOperation | TokenAmount;
  jackpotId: string;
}

export interface OperationsBuyTokenResponse {
  solAmount: number;
  jackpotId: string;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a OperationsBuyToken operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildOperationsBuyToken(tokenId: string, buyTokenId: string, data: OperationsBuyTokenRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `operations/${tokenId}/buyToken/${buyTokenId}`, document: doc };
}

/**
 * Authentication required. User buys SOF with SOL. Must pass jackpotId (open jackpot) and solAmount > 0. A fee (5 basis points) in SOL is diverted to the jackpot escrow and counted toward potLamports. Remaining SOL enters the bonding-curve pool; tokens are transferred to the buyer. Creating this document WILL EXECUTE hooks that perform these transfers and state updates. (Create/Update Single Item)
 */
export async function setOperationsBuyToken(tokenId: string, buyTokenId: string, data: OperationsBuyTokenRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`operations/${tokenId}/buyToken/${buyTokenId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting OperationsBuyToken: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view buy operations (passthrough).
   (Get Single Item)
 */
export async function getOperationsBuyToken(tokenId: string, buyTokenId: string): Promise<OperationsBuyTokenResponse | null> {
  try {
    const result = await get(`operations/${tokenId}/buyToken/${buyTokenId}`);
    return result as OperationsBuyTokenResponse | null;
  } catch (error) {
    console.error(`Error getting OperationsBuyToken: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single OperationsBuyToken document. (
  Read Operation Details: Public access. Anyone can view buy operations (passthrough).
  )
 */
export function subscribeOperationsBuyToken(callback: (data: OperationsBuyTokenResponse | null) => void, tokenId: string, buyTokenId: string): Promise<() => Promise<void>> {
  return subscribe(`operations/${tokenId}/buyToken/${buyTokenId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as OperationsBuyTokenResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to OperationsBuyToken at path '${`operations/${tokenId}/buyToken/${buyTokenId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many OperationsBuyToken items from collection operations/${tokenId}/buyToken
 
  Read Operation Details: Public access. Anyone can view buy operations (passthrough).
  
 */
export async function getManyOperationsBuyToken(tokenId: string, filter: string = ""): Promise<OperationsBuyTokenResponse[]> {
  try {
    const results = await get(`operations/${tokenId}/buyToken`, { prompt: filter });
    return Array.isArray(results) ? results as OperationsBuyTokenResponse[] : [];
  } catch (error) {
    console.error(`Error getting OperationsBuyToken collection at path 'operations/${tokenId}/buyToken': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in OperationsBuyToken collection at operations/${tokenId}/buyToken
 
  Read Operation Details: Public access. Anyone can view buy operations (passthrough).
  
 */
export function subscribeManyOperationsBuyToken(callback: (data: OperationsBuyTokenResponse[]) => void, tokenId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`operations/${tokenId}/buyToken`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as OperationsBuyTokenResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to OperationsBuyToken collection at path '${`operations/${tokenId}/buyToken`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: operations/$tokenId/sellToken/$sellTokenId ---

export interface OperationsSellTokenRequest {
  tokenAmount: number | TimeOperation | TokenAmount;
  jackpotId: string;
}

export interface OperationsSellTokenResponse {
  tokenAmount: number;
  jackpotId: string;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a OperationsSellToken operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildOperationsSellToken(tokenId: string, sellTokenId: string, data: OperationsSellTokenRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `operations/${tokenId}/sellToken/${sellTokenId}`, document: doc };
}

/**
 * Authentication required. User sells SOF for SOL. Must pass jackpotId and tokenAmount > 0. A fee (5 basis points) of the SOL proceeds is diverted to the jackpot pot. Creating this document WILL EXECUTE hooks that perform these transfers and state updates. (Create/Update Single Item)
 */
export async function setOperationsSellToken(tokenId: string, sellTokenId: string, data: OperationsSellTokenRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`operations/${tokenId}/sellToken/${sellTokenId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting OperationsSellToken: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can view sell operations (passthrough).
   (Get Single Item)
 */
export async function getOperationsSellToken(tokenId: string, sellTokenId: string): Promise<OperationsSellTokenResponse | null> {
  try {
    const result = await get(`operations/${tokenId}/sellToken/${sellTokenId}`);
    return result as OperationsSellTokenResponse | null;
  } catch (error) {
    console.error(`Error getting OperationsSellToken: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single OperationsSellToken document. (
  Read Operation Details: Public access. Anyone can view sell operations (passthrough).
  )
 */
export function subscribeOperationsSellToken(callback: (data: OperationsSellTokenResponse | null) => void, tokenId: string, sellTokenId: string): Promise<() => Promise<void>> {
  return subscribe(`operations/${tokenId}/sellToken/${sellTokenId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as OperationsSellTokenResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to OperationsSellToken at path '${`operations/${tokenId}/sellToken/${sellTokenId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many OperationsSellToken items from collection operations/${tokenId}/sellToken
 
  Read Operation Details: Public access. Anyone can view sell operations (passthrough).
  
 */
export async function getManyOperationsSellToken(tokenId: string, filter: string = ""): Promise<OperationsSellTokenResponse[]> {
  try {
    const results = await get(`operations/${tokenId}/sellToken`, { prompt: filter });
    return Array.isArray(results) ? results as OperationsSellTokenResponse[] : [];
  } catch (error) {
    console.error(`Error getting OperationsSellToken collection at path 'operations/${tokenId}/sellToken': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in OperationsSellToken collection at operations/${tokenId}/sellToken
 
  Read Operation Details: Public access. Anyone can view sell operations (passthrough).
  
 */
export function subscribeManyOperationsSellToken(callback: (data: OperationsSellTokenResponse[]) => void, tokenId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`operations/${tokenId}/sellToken`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as OperationsSellTokenResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to OperationsSellToken collection at path '${`operations/${tokenId}/sellToken`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: jackpots/$jackpotId/draws/$drawId ---

export interface JackpotsDrawsRequest {
  totalEntries: number | TimeOperation | TokenAmount;
  randomNumber?: number | TimeOperation | TokenAmount;
}

export interface JackpotsDrawsResponse {
  totalEntries: number;
  randomNumber?: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a JackpotsDraws operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildJackpotsDraws(jackpotId: string, drawId: string, data: JackpotsDrawsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `jackpots/${jackpotId}/draws/${drawId}`, document: doc };
}

/**
 * Admin-only ('6V9ng1g3UgafjCrCgXNBF4SwXbARB89YP9i8rAhY7Xem'). Creates a new draw for an open jackpot. Requires totalEntries > 0. Creating this document WILL EXECUTE a hook that generates a verifiable random number and stores it on-chain for auditability. (Create/Update Single Item)
 */
export async function setJackpotsDraws(jackpotId: string, drawId: string, data: JackpotsDrawsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`jackpots/${jackpotId}/draws/${drawId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting JackpotsDraws: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Public access. Anyone can inspect a draw and verify the random number used for winner selection.
   (Get Single Item)
 */
export async function getJackpotsDraws(jackpotId: string, drawId: string): Promise<JackpotsDrawsResponse | null> {
  try {
    const result = await get(`jackpots/${jackpotId}/draws/${drawId}`);
    return result as JackpotsDrawsResponse | null;
  } catch (error) {
    console.error(`Error getting JackpotsDraws: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single JackpotsDraws document. (
  Read Operation Details: Public access. Anyone can inspect a draw and verify the random number used for winner selection.
  )
 */
export function subscribeJackpotsDraws(callback: (data: JackpotsDrawsResponse | null) => void, jackpotId: string, drawId: string): Promise<() => Promise<void>> {
  return subscribe(`jackpots/${jackpotId}/draws/${drawId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as JackpotsDrawsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to JackpotsDraws at path '${`jackpots/${jackpotId}/draws/${drawId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many JackpotsDraws items from collection jackpots/${jackpotId}/draws
 
  Read Operation Details: Public access. Anyone can inspect a draw and verify the random number used for winner selection.
  
 */
export async function getManyJackpotsDraws(jackpotId: string, filter: string = ""): Promise<JackpotsDrawsResponse[]> {
  try {
    const results = await get(`jackpots/${jackpotId}/draws`, { prompt: filter });
    return Array.isArray(results) ? results as JackpotsDrawsResponse[] : [];
  } catch (error) {
    console.error(`Error getting JackpotsDraws collection at path 'jackpots/${jackpotId}/draws': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in JackpotsDraws collection at jackpots/${jackpotId}/draws
 
  Read Operation Details: Public access. Anyone can inspect a draw and verify the random number used for winner selection.
  
 */
export function subscribeManyJackpotsDraws(callback: (data: JackpotsDrawsResponse[]) => void, jackpotId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`jackpots/${jackpotId}/draws`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as JackpotsDrawsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to JackpotsDraws collection at path '${`jackpots/${jackpotId}/draws`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getRandomNumber" query on JackpotsDraws.
 * Query Logic: @data.randomNumber
 */
export async function runGetRandomNumberQueryForJackpotsDraws(jackpotId: string, drawId: string, ): Promise<number> {
  try {
    const result = await runQuery(`jackpots/${jackpotId}/draws/${drawId}`, "getRandomNumber", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getRandomNumber" on JackpotsDraws: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- End Generated SDK ---
